[{"title":"JDK1.8的新特性","date":"2019-09-21T16:00:00.000Z","path":"2019/09/22/jdk8新特性/","text":"JDK1.8的新特性1. 前言JDK1.8已经发布很久了，在很多企业中都已经在使用。并且Spring5、SpringBoot2.0都推荐使用JDK1.8以上版本。所以我们必须与时俱进，拥抱变化。 Jdk8这个版本包含语言、编译器、库、工具和JVM等方面的十多个新特性。在本文中我们将学习以下方面的新特性： [Lambda表达式](#2. Lambda表达式) [函数式接口](#3. 函数式接口) [方法引用](#4. 方法引用) [接口的默认方法和静态方法](#5. 接口的默认方法和静态方法) [Optional](#6. Optional) [Streams](#7. Streams) [并行数组](#8. 并行数组) 2. Lambda表达式函数式编程 Lambda 表达式，也可称为闭包，它是推动 Java 8 发布的最重要新特性。Lambda 允许把函数作为一个方法的参数（函数作为参数传递进方法中）。可以使代码变的更加简洁紧凑。 2.1 基本语法：1(参数列表) -&gt; &#123;代码块&#125; 需要注意： 参数类型可省略，编译器可以自己推断 如果只有一个参数，圆括号可以省略 代码块如果只是一行代码，大括号也可以省略 如果代码块是一行，且是有结果的表达式，return可以省略 注意：事实上，把Lambda表达式可以看做是匿名内部类的一种简写方式。当然，前提是这个匿名内部类对应的必须是接口，而且接口中必须只有一个函数！Lambda表达式就是直接编写函数的：参数列表、代码体、返回值等信息，用函数来代替完整的匿名内部类！ 2.2 用法示例示例1：多个参数准备一个集合： 12// 准备一个集合List&lt;Integer&gt; list = Arrays.asList(10, 5, 25, -15, 20); 假设我们要对集合排序，我们先看JDK7的写法，需要通过匿名内部类来构造一个Comparator： 12345678// Jdk1.7写法Collections.sort(list,new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; return o1 - o2; &#125;&#125;);System.out.println(list);// [-15, 5, 10, 20, 25] 如果是jdk8，我们可以使用新增的集合API：sort(Comparator c)方法，接收一个比较器，我们用Lambda来代替Comparator 的匿名内部类： 1234// Jdk1.8写法，参数列表的数据类型可省略：list.sort((i1,i2) -&gt; &#123; return i1 - i2;&#125;);System.out.println(list);// [-15, 5, 10, 20, 25] 对比一下Comparator中的compare()方法，你会发现：这里编写的Lambda表达式，恰恰就是compare()方法的简写形式，JDK8会把它编译为匿名内部类。是不是简单多了！ 别着急，我们发现这里的代码块只有一行代码，符合前面的省略规则，我们可以简写为： 123// Jdk8写法// 因为代码块是一个有返回值的表达式，可以省略大括号以及returnlist.sort((i1,i2) -&gt; i1 - i2); 示例2：单个参数还以刚才的集合为例，现在我们想要遍历集合中的元素，并且打印。 先用jdk1.7的方式： 1234// JDK1.7遍历并打印集合for (Integer i : list) &#123; System.out.println(i);&#125; jdk1.8给集合添加了一个方法：foreach() ，接收一个对元素进行操作的函数： 12// JDK1.8遍历并打印集合，因为只有一个参数，所以我们可以省略小括号:list.forEach(i -&gt; System.out.println(i)); 实例3：把Lambda赋值给变量Lambda表达式的实质其实还是匿名内部类，所以我们其实可以把Lambda表达式赋值给某个变量。 123456// 将一个Lambda表达式赋值给某个接口：Runnable task = () -&gt; &#123; // 这里其实是Runnable接口的匿名内部类，我们在编写run方法。 System.out.println(\"hello lambda!\");&#125;;new Thread(task).start(); 不过上面的用法很少见，一般都是直接把Lambda作为参数。 示例4：隐式finalLambda表达式的实质其实还是匿名内部类，而匿名内部类在访问外部局部变量时，要求变量必须声明为final！不过我们在使用Lambda表达式时无需声明final，这并不是说违反了匿名内部类的规则，因为Lambda底层会隐式的把变量设置为final，在后续的操作中，一定不能修改该变量： 正确示范： 1234567// 定义一个局部变量int num = -1;Runnable r = () -&gt; &#123; // 在Lambda表达式中使用局部变量num，num会被隐式声明为final System.out.println(num);&#125;;new Thread(r).start();// -1 错误案例： 1234567// 定义一个局部变量int num = -1;Runnable r = () -&gt; &#123; // 在Lambda表达式中使用局部变量num，num会被隐式声明为final，不能进行任何修改操作 System.out.println(num++);&#125;;new Thread(r).start();//报错 3. 函数式接口经过前面的学习，相信大家对于Lambda表达式已经有了初步的了解。总结一下： Lambda表达式是接口的匿名内部类的简写形式 接口必须满足：内部只有一个函数 其实这样的接口，我们称为函数式接口，我们学过的Runnable、Comparator都是函数式接口的典型代表。但是在实践中，函数接口是非常脆弱的，只要有人在接口里添加多一个方法，那么这个接口就不是函数接口了，就会导致编译失败。Java 8提供了一个特殊的注解@FunctionalInterface来克服上面提到的脆弱性并且显示地表明函数接口。而且jdk8版本中，对很多已经存在的接口都添加了@FunctionalInterface注解，例如Runnable接口： 另外，Jdk8默认提供了一些函数式接口供我们使用： 3.1 Function类型接口12345@FunctionalInterfacepublic interface Function&lt;T, R&gt; &#123; // 接收一个参数T，返回一个结果R R apply(T t);&#125; Function代表的是有参数，有返回值的函数。还有很多类似的Function接口： 接口名 描述 BiFunction&lt;T,U,R&gt; 接收两个T和U类型的参数，并且返回R类型结果的函数 DoubleFunction&lt;R&gt; 接收double类型参数，并且返回R类型结果的函数 IntFunction&lt;R&gt; 接收int类型参数，并且返回R类型结果的函数 LongFunction&lt;R&gt; 接收long类型参数，并且返回R类型结果的函数 ToDoubleFunction&lt;T&gt; 接收T类型参数，并且返回double类型结果 ToIntFunction&lt;T&gt; 接收T类型参数，并且返回int类型结果 ToLongFunction&lt;T&gt; 接收T类型参数，并且返回long类型结果 DoubleToIntFunction 接收double类型参数，返回int类型结果 DoubleToLongFunction 接收double类型参数，返回long类型结果 看出规律了吗？这些都是一类函数接口，在Function基础上衍生出的，要么明确了参数不确定返回结果，要么明确结果不知道参数类型，要么两者都知道。 3.2 Consumer系列12345@FunctionalInterfacepublic interface Consumer&lt;T&gt; &#123; // 接收T类型参数，不返回结果 void accept(T t);&#125; Consumer系列与Function系列一样，有各种衍生接口，这里不一一列出了。不过都具备类似的特征：那就是不返回任何结果。 3.3 Predicate系列12345@FunctionalInterfacepublic interface Predicate&lt;T&gt; &#123; // 接收T类型参数，返回boolean类型结果 boolean test(T t);&#125; Predicate系列参数不固定，但是返回的一定是boolean类型。 3.4 Supplier系列12345@FunctionalInterfacepublic interface Supplier&lt;T&gt; &#123; // 无需参数，返回一个T类型结果 T get();&#125; Supplier系列，英文翻译就是“供应者”，顾名思义：只产出，不收取。所以不接受任何参数，返回T类型结果。 4. 方法引用方法引用使得开发者可以将已经存在的方法作为变量来传递使用。方法引用可以和Lambda表达式配合使用。 4.1 语法：总共有四类方法引用： 语法 描述 类名::静态方法名 类的静态方法的引用 类名::非静态方法名 类的非静态方法的引用 实例对象::非静态方法名 类的指定实例对象的非静态方法引用 类名::new 类的构造方法引用 4.2 示例首先我们编写一个集合工具类，提供一个方法： 123456789101112131415public class CollectionUtil&#123; /** * 利用function将list集合中的每一个元素转换后形成新的集合返回 * @param list 要转换的源集合 * @param function 转换元素的方式 * @param &lt;T&gt; 源集合的元素类型 * @param &lt;R&gt; 转换后的元素类型 * @return */ public static &lt;T,R&gt; List&lt;R&gt; convert(List&lt;T&gt; list, Function&lt;T,R&gt; function)&#123; List&lt;R&gt; result = new ArrayList&lt;&gt;(); list.forEach(t -&gt; result.add(function.apply(t))); return result; &#125;&#125; 可以看到这个方法接收两个参数： List&lt;T&gt; list：需要进行转换的集合 Function&lt;T,R&gt;：函数接口，接收T类型，返回R类型。用这个函数接口对list中的元素T进行转换，变为R类型 接下来，我们看具体案例： 4.2.1 类的静态方法引用1List&lt;Integer&gt; list = Arrays.asList(1000, 2000, 3000); 我们需要把这个集合中的元素转为十六进制保存，需要调用Integer.toHexString()方法： 123public static String toHexString(int i) &#123; return toUnsignedString0(i, 4);&#125; 这个方法接收一个 i 类型，返回一个String类型，可以用来构造一个Function的函数接口： 我们先按照Lambda原始写法，传入的Lambda表达式会被编译为Function接口，接口中通过Integer.toHexString(i)对原来集合的元素进行转换： 123// 通过Lambda表达式实现List&lt;String&gt; hexList = CollectionUtil.convert(list, i -&gt; Integer.toHexString(i));System.out.println(hexList);// [3e8, 7d0, bb8] 上面的Lambda表达式代码块中，只有对Integer.toHexString()方法的引用，没有其它代码，因此我们可以直接把方法作为参数传递，由编译器帮我们处理，这就是静态方法引用： 123// 类的静态方法引用List&lt;String&gt; hexList = CollectionUtil.convert(list, Integer::toHexString;System.out.println(hexList);// [3e8, 7d0, bb8] 4.2.2 类的非静态方法引用接下来，我们把刚刚生成的String集合hexList中的元素都变成大写，需要借助于String类的toUpperCase()方法： 123public String toUpperCase() &#123; return toUpperCase(Locale.getDefault());&#125; 这次是非静态方法，不能用类名调用，需要用实例对象，因此与刚刚的实现有一些差别，我们接收集合中的每一个字符串s。但与上面不同然后s不是toUpperCase()的参数，而是调用者： 123// 通过Lambda表达式，接收String数据，调用toUpperCase()List&lt;String&gt; upperList = CollectionUtil.convert(hexList, s -&gt; s.toUpperCase());System.out.println(upperList);// [3E8, 7D0, BB8] 因为代码体只有对toUpperCase()的调用，所以可以把方法作为参数引用传递，依然可以简写： 123// 类的成员方法List&lt;String&gt; upperList = CollectionUtil.convert(hexList, String::toUpperCase);System.out.println(upperList);// [3E8, 7D0, BB8] 4.2.3 指定实例的非静态方法引用下面一个需求是这样的，我们先定义一个数字Integer num = 2000，然后用这个数字和集合中的每个数字进行比较，比较的结果放入一个新的集合。比较对象，我们可以用Integer的compareTo方法: 123public int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125; 先用Lambda实现， 123456List&lt;Integer&gt; list = Arrays.asList(1000, 2000, 3000);// 某个对象的成员方法Integer num = 2000;List&lt;Integer&gt; compareList = CollectionUtil.convert(list, i -&gt; num.compareTo(i));System.out.println(compareList);// [1, 0, -1] 与前面类似，这里Lambda的代码块中，依然只有对num.compareTo(i)的调用，所以可以简写。但是，需要注意的是，这次方法的调用者不是集合的元素，而是一个外部的局部变量num，因此不能使用 Integer::compareTo，因为这样是无法确定方法的调用者。要指定调用者，需要用 对象::方法名的方式： 1234// 某个对象的成员方法Integer num = 2000;List&lt;Integer&gt; compareList = CollectionUtil.convert(list, num::compareTo);System.out.println(compareList);// [1, 0, -1] 4.2.4 构造函数引用最后一个场景：把集合中的数字作为毫秒值，构建出Date对象并放入集合，这里我们就需要用到Date的构造函数： 1234567/** * @param date the milliseconds since January 1, 1970, 00:00:00 GMT. * @see java.lang.System#currentTimeMillis() */public Date(long date) &#123; fastTime = date;&#125; 我们可以接收集合中的每个元素，然后把元素作为Date的构造函数参数： 1234// 将数值类型集合，转为Date类型List&lt;Date&gt; dateList = CollectionUtil.convert(list, i -&gt; new Date(i));// 这里遍历元素后需要打印，因此直接把println作为方法引用传递了dateList.forEach(System.out::println); 上面的Lambda表达式实现方式，代码体只有new Date()一行代码，因此也可以采用方法引用进行简写。但问题是，构造函数没有名称，我们只能用new关键字来代替： 123// 构造方法List&lt;Date&gt; dateList = CollectionUtil.convert(list, Date::new);dateList.forEach(System.out::println); 注意两点： 上面代码中的System.out::println 其实是 指定对象System.out的非静态方法println的引用 如果构造函数有多个，可能无法区分导致传递失败 5. 接口的默认方法和静态方法Java 8使用两个新概念扩展了接口的含义：默认方法和静态方法。 5.1 默认方法默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。 默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下： 1234567891011121314151617private interface Defaulable &#123; // Interfaces now allow default methods, the implementer may or // may not implement (override) them. default String notRequired() &#123; return \"Default implementation\"; &#125; &#125;private static class DefaultableImpl implements Defaulable &#123;&#125;private static class OverridableImpl implements Defaulable &#123; @Override public String notRequired() &#123; return \"Overridden implementation\"; &#125;&#125; Defaulable接口使用关键字default定义了一个默认方法notRequired()。DefaultableImpl类实现了这个接口，同时默认继承了这个接口中的默认方法；OverridableImpl类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。 5.2 静态方法Java 8带来的另一个有趣的特性是在接口中可以定义静态方法，我们可以直接用接口调用这些静态方法。例子代码如下： 123456private interface DefaulableFactory &#123; // Interfaces now allow static methods static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) &#123; return supplier.get(); &#125;&#125; 下面的代码片段整合了默认方法和静态方法的使用场景： 12345678public static void main( String[] args ) &#123; // 调用接口的静态方法，并且传递DefaultableImpl的构造函数引用来构建对象 Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new ); System.out.println( defaulable.notRequired() ); // 调用接口的静态方法，并且传递OverridableImpl的构造函数引用来构建对象 defaulable = DefaulableFactory.create( OverridableImpl::new ); System.out.println( defaulable.notRequired() );&#125; 这段代码的输出结果如下： 12Default implementationOverridden implementation 由于JVM上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给java.util.Collection接口添加新方法，如stream()、parallelStream()、forEach()和removeIf()等等。 尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考官方文档。 6. OptionalJava应用中最常见的bug就是空值异常。 Optional仅仅是一个容器，可以存放T类型的值或者null。它提供了一些有用的接口来避免显式的null检查，可以参考Java 8官方文档了解更多细节。 接下来看一点使用Optional的例子：可能为空的值或者某个类型的值： 1234Optional&lt; String &gt; fullName = Optional.ofNullable( null );System.out.println( \"Full Name is set? \" + fullName.isPresent() ); System.out.println( \"Full Name: \" + fullName.orElseGet( () -&gt; \"[none]\" ) ); System.out.println( fullName.map( s -&gt; \"Hey \" + s + \"!\" ).orElse( \"Hey Stranger!\" ) ); 如果Optional实例持有一个非空值，则isPresent()方法返回true，否则返回false；如果Optional实例持有null，orElseGet()方法可以接受一个lambda表达式生成的默认值；map()方法可以将现有的Optional实例的值转换成新的值；orElse()方法与orElseGet()方法类似，但是在持有null的时候返回传入的默认值，而不是通过Lambda来生成。 上述代码的输出结果如下： 123Full Name is set? falseFull Name: [none]Hey Stranger! 再看下另一个简单的例子： 12345Optional&lt; String &gt; firstName = Optional.of( \"Tom\" );System.out.println( \"First Name is set? \" + firstName.isPresent() ); System.out.println( \"First Name: \" + firstName.orElseGet( () -&gt; \"[none]\" ) ); System.out.println( firstName.map( s -&gt; \"Hey \" + s + \"!\" ).orElse( \"Hey Stranger!\" ) );System.out.println(); 这个例子的输出是： 123First Name is set? trueFirst Name: TomHey Tom! 如果想了解更多的细节，请参考官方文档。 7. Streams新增的Stream API（java.util.stream）将生成环境的函数式编程引入了Java库中。这是目前为止最大的一次对Java库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。 Steam API极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫Task的类： 12345678910111213141516171819202122232425262728public class Streams &#123; private enum Status &#123; OPEN, CLOSED &#125;; private static final class Task &#123; private final Status status; private final Integer points; Task( final Status status, final Integer points ) &#123; this.status = status; this.points = points; &#125; public Integer getPoints() &#123; return points; &#125; public Status getStatus() &#123; return status; &#125; @Override public String toString() &#123; return String.format( \"[%s, %d]\", status, points ); &#125; &#125;&#125; Task类有一个points属性，另外还有两种状态：OPEN或者CLOSED。现在假设有一个task集合： 12345final Collection&lt; Task &gt; tasks = Arrays.asList( new Task( Status.OPEN, 5 ), new Task( Status.OPEN, 13 ), new Task( Status.CLOSED, 8 ) ); 首先看一个问题：在这个task集合中一共有多少个OPEN状态的？计算出它们的points属性和。在Java 8之前，要解决这个问题，则需要使用foreach循环遍历task集合；但是在Java 8中可以利用steams解决：包括一系列元素的列表，并且支持顺序和并行处理。 12345678// Calculate total points of all active tasks using sum()final long totalPointsOfOpenTasks = tasks .stream() .filter( task -&gt; task.getStatus() == Status.OPEN ) .mapToInt( Task::getPoints ) .sum();System.out.println( \"Total points: \" + totalPointsOfOpenTasks ); 运行这个方法的控制台输出是： 1Total points: 18 这里有很多知识点值得说。首先，tasks集合被转换成steam表示；其次，在steam上的filter操作会过滤掉所有CLOSED的task；第三，mapToInt操作基于tasks集合中的每个task实例的Task::getPoints方法将task流转换成Integer集合；最后，通过sum方法计算总和，得出最后的结果。 在学习下一个例子之前，还需要记住一些steams（点此更多细节）的知识点。Steam之上的操作可分为中间操作和晚期操作。 中间操作会返回一个新的steam——执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的steam，并将原steam中符合条件的元素放入新创建的steam。 晚期操作（例如forEach或者sum），会遍历steam并得出结果或者附带结果；在执行晚期操作之后，steam处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对steam进行遍历。 steam的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的tasks集合，我们可以用下面的代码计算所有task的points之和： 12345678// Calculate total points of all tasksfinal double totalPoints = tasks .stream() .parallel() .map( task -&gt; task.getPoints() ) // or map( Task::getPoints ) .reduce( 0, Integer::sum );System.out.println( \"Total points (all tasks): \" + totalPoints ); 这里我们使用parallel方法并行处理所有的task，并使用reduce方法计算最终的结果。控制台输出如下： 1Total points（all tasks）: 26.0 对于一个集合，经常需要根据某些条件对其中的元素分组。利用steam提供的API可以很快完成这类任务，代码如下： 12345// Group tasks by their statusfinal Map&lt; Status, List&lt; Task &gt; &gt; map = tasks .stream() .collect( Collectors.groupingBy( Task::getStatus ) );System.out.println( map ); 控制台的输出如下： 1&#123;CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]&#125; 最后一个关于tasks集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下： 123456789101112// Calculate the weight of each tasks (as percent of total points) final Collection&lt; String &gt; result = tasks .stream() // Stream&lt; String &gt; .mapToInt( Task::getPoints ) // IntStream .asLongStream() // LongStream .mapToDouble( points -&gt; points / totalPoints ) // DoubleStream .boxed() // Stream&lt; Double &gt; .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream .mapToObj( percentage -&gt; percentage + \"%\" ) // Stream&lt; String&gt; .collect( Collectors.toList() ); // List&lt; String &gt; System.out.println( result ); 控制台输出结果如下： 1[19%, 50%, 30%] 最后，正如之前所说，Steam API不仅可以作用于Java集合，传统的IO操作（从文件或者网络一行一行得读取数据）可以受益于steam处理，这里有一个小例子： 1234final Path path = new File( filename ).toPath();try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) &#123; lines.onClose( () -&gt; System.out.println(\"Done!\") ).forEach( System.out::println );&#125; Stream的方法onClose() 返回一个等价的有额外句柄的Stream，当Stream的close()方法被调用的时候这个句柄会被执行。Stream API、Lambda表达式还有接口默认方法和静态方法支持的方法引用，是Java 8对软件开发的现代范式的响应。 8. 并行数组Java8版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是parallelSort()，可以显著加快多核机器上的数组排序。下面的例子论证了parallexXxx系列的方法： 123456789101112131415161718192021package com.javacodegeeks.java8.parallel.arrays;import java.util.Arrays;import java.util.concurrent.ThreadLocalRandom;public class ParallelArrays &#123; public static void main( String[] args ) &#123; long[] arrayOfLong = new long [ 20000 ]; Arrays.parallelSetAll( arrayOfLong, index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) ); Arrays.stream( arrayOfLong ).limit( 10 ).forEach( i -&gt; System.out.print( i + \" \" ) ); System.out.println(); Arrays.parallelSort( arrayOfLong ); Arrays.stream( arrayOfLong ).limit( 10 ).forEach( i -&gt; System.out.print( i + \" \" ) ); System.out.println(); &#125;&#125; 上述这些代码使用parallelSetAll()方法生成20000个随机数，然后使用parallelSort()方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是： 12Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 Sorted: 39 220 263 268 325 607 655 678 723 793","comments":true,"link":"","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/categories/Java基础/"}],"tags":[{"name":"stream","slug":"stream","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/stream/"},{"name":"lambda","slug":"lambda","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/lambda/"},{"name":"Java中级","slug":"Java中级","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/Java中级/"}]},{"title":"Markdown 简洁语法说明","date":"2019-09-21T12:03:04.000Z","path":"2019/09/21/Markdown-简洁语法说明/","text":"0.前言一直以来都是以word文档做笔记，存在很多问题，比如代码格式、高亮等。这次公司要求使用markdown，感觉眼前一亮，以前word的问题都得到了解决，而且可以生成电子书，或者直接通过gitbook放到网络中，非常棒。 但是很多的同事可能与我一样，之前对markdown并不熟悉，所以对语法、typora的快捷键都不太熟悉，因此就有了本文。 1、基本语法1.1 多级标题语法在Markdown中，如果想将一段文字定义为标题，只需要在这段文字前面加上 #，再在 # 后加一个空格即可。还可增加二、三、四、五、六级标题，总共六级。每多一级 ，增加一个 # ，标题字号相应降低一级。如图： 快捷键在typora中，1级标题对应的快捷键是：CTRL + 1 ，其它级别分别对应2~6的数字即可 1.2 列表语法说明列表格式也很常用，它可以让你的文稿变得井井有条。在 Markdown 中，你只需要在文字前面加上 - 就可以了；如果你希望是有序列表，在文字前面加上 1. 或2. 或3. 即可。 注意：无论是- 还是 1.都需要在后面跟上一个空格 快捷键typora中并没有对应快捷键，不过在菜单中有对应选项： 1.3 引用语法说明如果你需要在文稿中引用一段别处的句子，那么就要用到「引用」格式。 在引用文字前加上 &gt; 并与文字保留一个字符的空格即可。如图： 快捷键typora中的快捷键是：CTRL+SHIFT+Q 1.4 粗体和斜体语法说明Markdown 的粗体和斜体也非常简单： 用两个 * 包含一段文本就是粗体的语法； 用一个 * 包含一段文本就是斜体的语法。 如图： 快捷键typora中的快捷键： ​ 粗体：Ctrl + B ​ 斜体：Ctrl + I ​ 下划线：Ctrl + U 1.5 链接语法说明在 Markdown 中，插入链接的语法如下： 1[链接文本](链接地址) 快捷键typora中的快捷键是：Ctrl + K 1.6 图片语法说明在 Markdown 中，插入图片的语法如下： 1![图片说明文字](链接地址) 快捷键typora中的快捷键是：Ctrl + Shift + I 1.7 分割线分割线的语法只需要另起一行，连续输入三个星号 *** 即可分割两段文字内容。 1.8 表格表格输入相对复杂，推荐使用工具自带功能实现 语法说明 快捷键typora的快捷键：Ctrl + T 弹出菜单： 生成的表格： 1.9 代码高亮语法说明行内代码块： 1`代码` 段落代码块： 123​```语言类型代码​ 123456789101112131415示例：![1523757176213](Markdown-简洁语法说明/code.png)#### 快捷键行内代码：```markdownCtrl + Shift + `","comments":true,"link":"","categories":[{"name":"工具手册-markdown","slug":"工具手册-markdown","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/categories/工具手册-markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/markdown/"},{"name":"语法","slug":"语法","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/语法/"},{"name":"入门","slug":"入门","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/入门/"}]},{"title":"Hello World","date":"2019-09-15T12:03:04.000Z","path":"2019/09/15/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"link":"","categories":[{"name":"工具手册-hexo+yilia","slug":"工具手册-hexo-yilia","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/categories/工具手册-hexo-yilia/"}],"tags":[{"name":"语法","slug":"语法","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/语法/"},{"name":"入门","slug":"入门","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/入门/"},{"name":"hexo","slug":"hexo","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/hexo/"}]},{"title":"发布后样式加载不出来的问题","date":"2017-05-26T04:12:57.000Z","path":"2017/05/26/静态样式加载不出来/","text":"使用HEXO+GITHUB PAGES搭建个人博客，在本地服务器没有任何问题，但是在外网访问页面样式加载不出来。 因为需要修改_CONFIG.YML文件中的网址和网站根目录 12345678bash: # URL&lt;br&gt; ## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and &lt;br&gt;root as &apos;/child/&apos;&lt;br&gt; url: https://banjingwei.github.io/ban.github.io&lt;br&gt; root: /ban.github.io/&lt;br&gt; permalink: :year/:month/:day/:title/&lt;br&gt; permalink_defaults:&lt;br&gt; More info: 提示内容如下： 如果您的网站存放在子目录中，例如 HTTP://YOURSITE.COM/BLOG，则请将您的 URL 设为 HTTP://YOURSITE.COM/BLOG 并把 ROOT 设为 /BLOG/。 使用GITHUB PAGES搭建博客，网址就是：1$ https://github.com/GitHubWxw/GitHubWxw.github.io 也就是GITHUB PAGES分配给我们的网址根目录：/GitHubWxw.github.io/是搭建博客仓库的名称 root: /GitHubWxw.github.io/ Deploy to remote sites1$ hexo deploy","comments":true,"link":"","categories":[{"name":"bug收纳筐","slug":"bug收纳筐","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/categories/bug收纳筐/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/markdown/"},{"name":"语法","slug":"语法","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/语法/"},{"name":"入门","slug":"入门","permalink":"https://github.com/GitHubWxw/GitHubWxw.github.io/tags/入门/"}]}]