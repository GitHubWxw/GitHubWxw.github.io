(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{292:function(e,t,a){"use strict";a.r(t);var s=a(0),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h3",{attrs:{id:"_1-mysql版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-mysql版本","aria-hidden":"true"}},[e._v("#")]),e._v(" 1. MySql版本")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("5.x:")]),e._v(" "),a("li",[e._v("5.0-5.1:早期产品的延续，升级维护")]),e._v(" "),a("li",[e._v("5.4 - 5.x :  MySQL整合了三方公司的新存储引擎 （推荐5.5）")])])]),e._v(" "),a("h4",{attrs:{id:"（1）基本操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）基本操作","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）基本操作")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("启动mysql应用： service mysql start")]),e._v(" "),a("li",[e._v("关闭： service mysql stop")]),e._v(" "),a("li",[e._v("重启： service mysql restart")])]),e._v(" "),a("p",[e._v("注意：")]),e._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('在计算机reboot后 登陆MySQL :  mysql\n\t可能会报错：   "/var/lib/mysql/mysql.sock不存在"  \n\t--原因：是Mysql服务没有启动\n解决办法：\n    （1） 启动服务： 1.每次使用前 手动启动服务   /etc/init.d/mysql start\n    （2）开机自启   chkconfig mysql on     ,  chkconfig mysql off    \n    （3）检查开机是否自动启动： ntsysv\t\n')])])]),a("ul",[a("li",[e._v("设置密码：给mysql 的超级管理员root 增加密码：/usr/bin/mysqladmin -u root password root")]),e._v(" "),a("li",[e._v("登录：mysql -u root -p")])]),e._v(" "),a("p",[e._v("数据库存放目录：")]),e._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("ps -ef|grep mysql  可以看到：\n\t\t数据库目录：     datadir=/var/lib/mysql \n\t\tpid文件目录： --pid-file=/var/lib/mysql/bigdata01.pid\n\n\t\tMySQL核心目录：\n\t\t\t/var/lib/mysql :mysql 安装目录\n\t\t\t/usr/share/mysql:  配置文件\n\t\t\t/usr/bin：命令目录（mysqladmin、mysqldump等）\n\t\t\t/etc/init.d/mysql启停脚本\nMySQL配置文件\n      my-huge.cnf\t高端服务器  1-2G内存\n      my-large.cnf   中等规模\n      my-medium.cnf  一般\n      my-small.cnf   较小\n      但是，以上配置文件mysql默认不能识别，默认只能识别 /etc/my.cnf\n      采用 my-huge.cnf ：\n      cp /usr/share/mysql/my-huge.cnf /etc/my.cnf\n      注意：mysql5.5默认配置文件/etc/my.cnf；Mysql5.6 默认配置文件/etc/mysql-default.cnf\n")])])])]),e._v(" "),a("h4",{attrs:{id:"（2）mysql字符编码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）mysql字符编码","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）mysql字符编码")]),e._v(" "),a("blockquote",[a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("sql  :  show variables like '%char%' ;\n\t\t可以发现部分编码是 latin,需要统一设置为utf-8\n\t\t设置编码：\n\t\tvi /etc/my.cnf:\n\t\t[mysql]\n\t\tdefault-character-set=utf8\n\t\t[client]\n\t\tdefault-character-set=utf8\n\t\t\n\t\t[mysqld]\n\t\tcharacter_set_server=utf8\n\t\tcharacter_set_client=utf8\n\t\tcollation_server=utf8_general_ci\n\n\t重启Mysql:  service mysql restart\n\t\tsql  :  show variables like '%char%' ;\n注意事项：修改编码 只对“之后”创建的数据库生效，因此 我们建议 在mysql安装完毕后，第一时间 统一编码。\n")])])]),a("p",[e._v("小提示：mysql:清屏    ctrl+L    , system clear")])]),e._v(" "),a("h3",{attrs:{id:"_2-mysql原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-mysql原理","aria-hidden":"true"}},[e._v("#")]),e._v(" 2. mysql原理")]),e._v(" "),a("blockquote",[a("p",[e._v("（1）MYSQL逻辑分层 ：连接层 服务层 引擎层 存储层")]),e._v(" "),a("ul",[a("li",[e._v("InnoDB(默认) ：事务优先 （适合高并发操作；行锁）")]),e._v(" "),a("li",[e._v("MyISAM ：性能优先  （表锁）")])]),e._v(" "),a("p",[e._v("（2）引擎")]),e._v(" "),a("ul",[a("li",[e._v("查询数据库引擎：  支持哪些引擎？ show engines ;")]),e._v(" "),a("li",[e._v("查看当前使用的引擎   show variables like '%storage_engine%' ;")])]),e._v(" "),a("p",[e._v("（3）创建表的时候指定引擎和默认字符编码")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create table tb(\n\t\tid int(4) auto_increment ,\n\t\tname varchar(5),\n\t\tdept varchar(5) ,\n\t\tprimary key(id)\t\t\n\t)ENGINE=MyISAM AUTO_INCREMENT=1\n\t DEFAULT CHARSET=utf8   ;\n")])])])]),e._v(" "),a("h3",{attrs:{id:"_3-sql优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-sql优化","aria-hidden":"true"}},[e._v("#")]),e._v(" 3. SQL优化")]),e._v(" "),a("p",[e._v("​    "),a("strong",[e._v("优化原因：")])]),e._v(" "),a("p",[e._v("​          性能低、执行时间太长、等待时间太长、SQL语句欠佳（连接查询）、索引失效、服务器参数设置不合理（缓冲、线程数）")]),e._v(" "),a("h4",{attrs:{id:"（1）sql语句"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）sql语句","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）SQL语句")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("编写过程")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select dinstinct  ..from  ..join ..on ..where ..group by ...having ..order by ..limit ..\n")])])]),a("ul",[a("li",[e._v("解析过程")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from .. on.. join ..where ..group by ....having ...select dinstinct ..order by limit ...\n")])])])]),e._v(" "),a("h4",{attrs:{id:"（2）sql优化本质"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）sql优化本质","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）SQL优化本质")]),e._v(" "),a("p",[e._v("​     "),a("strong",[e._v("SQL优化主要是在优化索引")])]),e._v(" "),a("blockquote",[a("ul",[a("li",[a("p",[e._v("索引（比喻）：相当于书的目录")])]),e._v(" "),a("li",[a("p",[e._v("索引（概述）：")]),e._v(" "),a("p",[e._v("index索引是帮助mysql高效获取数据的数据结构。索引的数据结构（树：B树(默认)、Hash树...）")])])]),e._v(" "),a("p",[e._v("举例：")]),e._v(" "),a("p",[e._v("（1）B树索引：")]),e._v(" "),a("p",[e._v("（2）索引的原理")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("索引的弊端：")]),e._v(" "),a("p",[e._v("1.索引本身很大， 可以存放在内存/硬盘（通常为 硬盘）\n2.索引不是所有情况均适用： a.少量数据  b.频繁更新的字段   c.很少使用的字段\n3.索引会降低增删改的效率（增删改  查）")])]),e._v(" "),a("li",[a("p",[e._v("索引的优势：")]),e._v(" "),a("p",[e._v("1.提高查询效率（降低IO使用率）")]),e._v(" "),a("p",[e._v("2.降低CPU使用率 （...order by age desc,因为 B树索引 本身就是一个 好排序的结构，因此在排序时  可以直接使用）")])])]),e._v(" "),a("p",[e._v("MySQL执行流程推荐：")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://www.cnblogs.com/annsshadow/p/5037667.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("MySQL总体架构---\x3e查询执行流程---\x3e语句执行顺序"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"_4-索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-索引","aria-hidden":"true"}},[e._v("#")]),e._v(" 4. 索引")]),e._v(" "),a("h4",{attrs:{id:"（1）分类"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）分类","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）分类")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("主键索引：不能重复  Id、不是null")]),e._v(" "),a("li",[e._v("唯一索引：不能重复  Id、可以是null")]),e._v(" "),a("li",[e._v("单值索引：单列  age、一个表可以多个单值索引,name。")]),e._v(" "),a("li",[e._v("复合索引：多个列构成的索引 （相当于 二级目录 ：  z: zhao）  (name,age)   (a,b,c,d,...,n)")])])]),e._v(" "),a("h4",{attrs:{id:"（2）创建索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）创建索引","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）创建索引")]),e._v(" "),a("blockquote",[a("ul",[a("li",[a("strong",[e._v("方式一")])])]),e._v(" "),a("p",[a("code",[e._v("create 索引类型 索引名 on 表(字段)")])]),e._v(" "),a("ul",[a("li",[e._v("下面索引举例参照上面的tb表如下：")])]),e._v(" "),a("p",[e._v("a. 单值索引")]),e._v(" "),a("p",[a("code",[e._v("create index dept_index on tb(dept);")])]),e._v(" "),a("p",[e._v("b. 唯一索引")]),e._v(" "),a("p",[a("code",[e._v("create unique index name_index on tb(name)")])]),e._v(" "),a("p",[e._v("c. 复合索引")]),e._v(" "),a("p",[a("code",[e._v("create index dept_name_index on tb(dept,name)")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("方式二")])])]),e._v(" "),a("p",[e._v("alter table 表名 索引类型  索引名（字段）")]),e._v(" "),a("p",[e._v("a. 单值索引")]),e._v(" "),a("p",[a("code",[e._v("alter table tb add index dept_index(dept);")])]),e._v(" "),a("p",[e._v("b. 唯一索引")]),e._v(" "),a("p",[a("code",[e._v("alter table tb add unique index name_index(name)")])]),e._v(" "),a("p",[e._v("c. 复合索引")]),e._v(" "),a("p",[a("code",[e._v("alter table tb add index dept_name_index(dept,name);")])]),e._v(" "),a("p",[e._v("**注意：**如果一个字段是primary key,则改动字段默认就是  主键索引")])]),e._v(" "),a("h4",{attrs:{id:"（2）删除索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）删除索引","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）删除索引")]),e._v(" "),a("blockquote",[a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("drop index 索引名 on 表名 ;\ndrop index name_index on tb ;\n")])])])]),e._v(" "),a("h4",{attrs:{id:"（3）查询索引"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（3）查询索引","aria-hidden":"true"}},[e._v("#")]),e._v(" （3）查询索引")]),e._v(" "),a("blockquote",[a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("show index from 表名 ;\nshow index from 表名 \\G\n")])])]),a("p",[a("strong",[e._v("注意：")])]),e._v(" "),a("ul",[a("li",[e._v("只有DML(数据库管理语言),数据库的增删改需要commit")]),e._v(" "),a("li",[e._v("而DDL数据库定义语言，不需要commit,他会自动提交")])])]),e._v(" "),a("h3",{attrs:{id:"_5-sql性能问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-sql性能问题","aria-hidden":"true"}},[e._v("#")]),e._v(" 5. SQL性能问题")]),e._v(" "),a("h4",{attrs:{id:"（1）瓶颈："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）瓶颈：","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）瓶颈：")]),e._v(" "),a("blockquote",[a("p",[e._v("a. 分析SQL的执行计划："),a("strong",[e._v("explain")]),e._v(",可以模拟SQL优化器执行SQL语句，从而让开发人员 知道自己编写的SQL状况")]),e._v(" "),a("p",[e._v("b. MySQL查询优化其会干扰我们的优化")]),e._v(" "),a("p",[e._v("**优化方法:**官网：https://dev.mysql.com/doc/refman/5.5/en/optimization.html")])]),e._v(" "),a("h4",{attrs:{id:"（2）查询执行计划"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）查询执行计划","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）查询执行计划")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("explain +SQL语句")])]),e._v(" "),a("p",[a("code",[e._v("explain select * from tb;")])]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("explain各个字段的意义描述")])])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("id : 编号\t\t\t\t\nselect_type ：查询类型\ntable ：表\ntype   ：类型\npossible_keys ：预测用到的索引 \nkey  ：实际使用的索引\nkey_len ：实际使用索引的长度     \nref  :表之间的引用\nrows ：通过索引查询到的数据量 \nExtra     :额外的信息\n")])])]),a("p",[e._v("（1）准备数据")]),e._v(" "),a("p",[e._v("SQL语句：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create table course\n(\ncid int(3),\ncname varchar(20),\ntid int(3)\n);\ncreate table teacher\n(\ntid int(3),\ntname varchar(20),\ntcid int(3)\n);\n\ncreate table teacherCard\n(\ntcid int(3),\ntcdesc varchar(200)\n);\n")])])]),a("p",[e._v("插入数据：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("insert into course values(1,'java',1);\ninsert into course values(2,'html',1);\ninsert into course values(3,'sql',2);\ninsert into course values(4,'web',3);\n\ninsert into teacher values(1,'tz',1);\ninsert into teacher values(2,'tw',2);\ninsert into teacher values(3,'tl',3);\n\ninsert into teacherCard values(1,'tzdesc') ;\ninsert into teacherCard values(2,'twdesc') ;\ninsert into teacherCard values(3,'tldesc') ;\n")])])])]),e._v(" "),a("h4",{attrs:{id:"（3）id字段"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（3）id字段","aria-hidden":"true"}},[e._v("#")]),e._v(" （3）ID字段")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("查询课程编号为2  或 教师证编号为3  的老师信息")]),e._v(" "),a("li",[e._v("explain +sql:")])]),e._v(" "),a("ol",[a("li",[a("p",[e._v("id: id值相同，从上往下 顺序执行。\\")]),e._v(" "),a("p",[e._v("​       t3-tc3-c4")]),e._v(" "),a("p",[e._v("​      tc3--c4-t6")])]),e._v(" "),a("li",[a("p",[e._v("表的执行顺序  因数量的个数改变而改变的原因： 笛卡儿积")]),e._v(" "),a("div",{staticClass:"language-pascal extra-class"},[a("pre",{pre:!0,attrs:{class:"language-pascal"}},[a("code",[e._v("    a \t b    c\n\t"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),e._v("\t"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("\t "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("  \t "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("6")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),e._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("24")]),e._v("\n\t\t\t\t\t\t"),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("4")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("12")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("*")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),e._v("   "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("24")]),e._v("    \n")])])]),a("p",[a("strong",[e._v("分析")])]),e._v(" "),a("p",[e._v("（1）当id相同时，数据小的表 优先查询；（因为查询是借助内存，当然内存放的数据越小越好）")]),e._v(" "),a("p",[e._v("（2）当id值不同：id值越大越优先查询 (本质：在嵌套子查询时，先查内层 再查外层)")])])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("查询教授SQL课程的老师的描述（desc）")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select tc.tcdesc from teacherCard tc,course c,teacher t where c.tid = t.tid\nand t.tcid = tc.tcid and c.cname = 'sql' ;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("将以上 多表查询 转为子查询形式：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select tc.tcdesc from teacherCard tc where tc.tcid = \n(select t.tcid from teacher t where  t.tid =  \n\t(select c.tid from course c where c.cname = 'sql')\n);\n")])])])]),e._v(" "),a("li",[a("p",[e._v("子查询+多表：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select t.tname ,tc.tcdesc from teacher t,teacherCard tc where t.tcid= tc.tcid\nand t.tid = (select c.tid from course c where cname = 'sql') ;\n")])])])])]),e._v(" "),a("p",[e._v("（3）id值有相同，又有不同： id值越大越优先；id值相同，从上往下 顺序执行")])]),e._v(" "),a("h4",{attrs:{id:"（4）select-type-查询类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（4）select-type-查询类型","aria-hidden":"true"}},[e._v("#")]),e._v(" （4）select_type:查询类型")]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("primary:包含子查询SQL中的 主查询 （最外层）")]),e._v(" "),a("li",[e._v("subquery：包含子查询SQL中的 子查询 （非最外层）")]),e._v(" "),a("li",[e._v("simple:简单查询（不包含子查询、union）")]),e._v(" "),a("li",[e._v("derived:衍生查询(使用到了临时表)")])]),e._v(" "),a("p",[e._v("（1）方式一：a.在from子查询中只有一张表")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select  cr.cname \tfrom ( select * from course where tid in (1,2) ) cr ;\n")])])]),a("p",[e._v("（2）b.在from子查询中， 如果有table1 union table2 ，则table1 就是derived,table2就是union")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select  cr.cname \tfrom ( select * from course where tid = 1  union select * from course where tid = 2 ) cr ;\n")])])]),a("p",[a("strong",[e._v("知识补充")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("主要用于连接查询，联合两个数据表，把两个表中所有的字段合成一张大表。")])]),e._v(" "),a("li",[a("p",[e._v("UNION 指令的目的：将两个SQL的结果集合并起来，从这个角度看，union 跟join 有些类似，因为这两个指令都可以由多个表中截取资料")])]),e._v(" "),a("li",[a("p",[e._v("UNION 的一个限制是两个 SQL 语句所产生的栏位需要是同样的资料种类。另外，当我们用 UNION这个指令时，我们只会看到不同的资料值 (类似 select distinct)。")])])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("UNION 的语法如下：\n\t[SQL 语句 1]\n\tUNION\n\t[SQL 语句 2]\n")])])]),a("ul",[a("li",[a("p",[e._v("union:上例")])]),e._v(" "),a("li",[a("p",[e._v("union result :告知开发人员，那些表之间存在union查询")])])])]),e._v(" "),a("h4",{attrs:{id:"（5）type-索引类型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（5）type-索引类型","aria-hidden":"true"}},[e._v("#")]),e._v(" （5）type:索引类型")]),e._v(" "),a("pre",[a("code",[e._v("   ```mysql\n")])]),e._v(" "),a("p",[e._v("system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL\n```")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("优化一般级别：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("system>const>eq_ref>ref>range>index>all   ，要对type进行优化的前提：有索引\n\n其中：system,const只是理想情况；实际能达到 ref>range\n")])])])]),e._v(" "),a("li",[a("p",[e._v("system（忽略）: 只有一条数据的系统表 ；或 衍生表只有一条数据的主查询")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create table test01\n(\n\ttid int(3),\n\ttname varchar(20)\n);\n\ninsert into test01 values(1,'a') ;\ncommit;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("(1) 增加索引")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("alter table test01 add constraint tid_pk primary key(tid) ;\nexplain select * from (select * from test01 )t where tid =1 ;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("const：仅仅能查到一条数据的SQL ,用于Primary key 或unique索引  （类型 与索引类型有关）")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select tid from test01 where tid =1 ;\nalter table test01 drop primary key ;\ncreate index test01_index on test01(tid) ;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("eq_ref:唯一性索引：对于每个索引键的查询，返回匹配唯一行数据（有且只有1个，不能多 、不能0）")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select ... from ..where name = ... .常见于唯一索引 和主键索引。\n\nalter table teacherCard add constraint pk_tcid primary key(tcid);\nalter table teacher add constraint uk_tcid unique index(tcid) ;\n\nexplain select t.tcid from teacher t,teacherCard tc where t.tcid = tc.tcid ;\n")])])]),a("p",[a("strong",[e._v("注意")])]),e._v(" "),a("p",[e._v("以上SQL，用到的索引是 t.tcid,即teacher表中的tcid字段；\n如果teacher表的数据个数 和 连接查询的数据个数一致（都是3条数据），则有可能满足eq_ref级别；否则无法满足。")]),e._v(" "),a("p",[e._v("​")])]),e._v(" "),a("li",[a("p",[e._v("ref：非唯一性索引，对于每个索引键的查询，返回匹配的所有行（0，多）")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("准备数据：\n insert into teacher values(4,'tz',4) ;\n insert into teacherCard values(4,'tz222');\n\n测试：\nalter table teacher add index index_name (tname) ;\nexplain select * from teacher \twhere tname = 'tz';\n")])])])]),e._v(" "),a("li",[a("p",[e._v("range：检索指定范围的行 ,where后面是一个范围查询(between   ,> < >=,     特殊:in有时候会失效 ，")]),e._v(" "),a("p",[e._v("从而转为 无索引all)")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("alter table teacher add index tid_index (tid) ;\nexplain select t.* from teacher t where t.tid in (1,2) ;\nexplain select t.* from teacher t where t.tid <3 6 10="大表.y" 300="小表.x" ;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("index：查询全部索引中数据")]),e._v(" "),a("p",[a("code",[e._v("explain select tid from teacher ; --tid 是索引， 只需要扫描索引表，不需要所有表中的所有数据")])])]),e._v(" "),a("li",[a("p",[e._v("all：查询全部表中的数据")]),e._v(" cid course --cid不是索引，需要全表所有，即需要所有表中的所有数据")])])])]),e._v(" "),a("p",[a("strong",[e._v("对于explain的字段类型小结：：")])]),e._v(" "),a("ul",[a("li",[e._v("system const: 结果只有一条数据")]),e._v(" "),a("li",[e._v("eq_ref:结果多条；但是每条数据是唯一的 ；")]),e._v(" "),a("li",[e._v("ref：结果多条；但是每条数据是是0或多条 ；")])]),e._v(" "),a("h4",{attrs:{id:"（6）possible-keys-主键"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#（6）possible-keys-主键","aria-hidden":"true"}},[e._v("#")]),e._v(" （6）possible_keys 主键")]),e._v(" "),a("blockquote",[a("p",[e._v("可能用到的索引，是一种预测，不准。")])]),e._v(" "),a("div",{staticclass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("alter table add index cname_index (cname);\n\nexplain t.tname ,tc.tcdesc t,teachercard tc\n where t.tcid="tc.tcid\nand" t.tid="(select" c.tid c cname="sql" ) ;\n")])])]),a("blockquote",[a("ol",[a("li",[a("p",[e._v("如果 possible_key key是null，则说明没用索引")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain tc.tcdesc teachercard tc,course c,teacher t and c.cname="sql" ;\n")])])])])])]),e._v(" "),a("h4",{attrs:{id:"（7）key"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#（7）key","aria-hidden":"true"}},[e._v("#")]),e._v(" （7）key")]),e._v(" "),a("blockquote",[a("p",[e._v("实际使用到的索引")])]),e._v(" "),a("h4",{attrs:{id:"（8）key-len-：索引的长度"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#（8）key-len-：索引的长度","aria-hidden":"true"}},[e._v("#")]),e._v(" （8）key_len ：索引的长度")]),e._v(" "),a("blockquote",[a("p",[e._v("作用：用于判断复合索引是否被完全使用 （a,b,c）。")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create test_kl\n(\n\tname char(20) not null default ''\n);\nalter test_kl index_name(name) ;\nexplain * name -- key_len :60\n在utf8：1个字符站3个字节 \n\nalter column name1 --name1可以为null\n\nalter index_name1(name1) \n--如果索引字段可以为null,则会使用1个字节用于标识。\n\ndrop index_name on ;\ndrop index_name1 ;\n\n增加一个复合索引 \nalter name_name1_index (name,name1) \n\nexplain --121\nexplain --60\n\n\nvarchar(20)\nalter name2 varchar(20) --可以为null name2_index (name2) ;\n\nexplain --63 （数据的总字节数，即长度）\n20*3="60" + 1(null) +2(用2个字节 标识可变长度)="63\n" )])])]),a("p",[a("strong",[e._v("注意：")])]),e._v("" "),a("ul",[a("li",[e._v("mysql表示varchar可变长度为2个字节 null标识1个字节 得到最终长度")]),e._v(" "),a("li",[e._v("utf8:1个字符3个字节")]),e._v(" "),a("li",[e._v("gbk:1个字符2个字节")]),e._v(" "),a("li",[e._v("latin:1个字符1个字节")])])]),e._v(" "),a("h4",{attrs:{id:"（9）ref"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#（9）ref","aria-hidden":"true"}},[e._v("#")]),e._v(" （9）ref")]),e._v(" "),a("blockquote",[a("p",[e._v("ref : 注意与type中的ref值区分。\n作用： 指明当前表所 参照的 字段。")]),e._v(" "),a("p",[a("code",[e._v("select ....where a.c="b.x" ;(其中b.x可以是常量，const)")])]),e._v(" tid_index (tid) "),a("h4",{attrs:{id:"（10）rows"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#（10）rows","aria-hidden":"true"}},[e._v("#")]),e._v(" （10）rows")]),e._v(" "),a("blockquote",[a("p",[e._v("被索引优化查询的 数据个数 (实际通过索引而查询到的 数据个数)")]),e._v(" ;")])])]),e._v(" "),a("h4",{attrs:{id:"（11）extra"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#（11）extra","aria-hidden":"true"}},[e._v("#")]),e._v(" （11）extra")]),e._v(" "),a("blockquote",[a("ol",[a("li",[a("p",[e._v("(i).using filesort ： 性能消耗大；需要“额外”的一次排序（查询） 。常见于 order by 语句中。\n排序：先查询")]),e._v(" "),a("p",[e._v("场景：10个人 根据年龄排序。")]),e._v(" test02\n(\n\ta1 char(3),\n\ta2 char(3),\n\ta3 char(3),\n\tindex idx_a1(a1),\n\tindex idx_a2(a2),\n\tindex idx_a3(a3)\n);\n\nexplain test02 a1 ;\n\na1:姓名 a2：年龄\nexplain a2 --using filesort\n")])])]),a("p",[a("strong",[e._v("小结：")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("对于单索引， 如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using")])]),e._v(" "),a("li",[a("p",[e._v("filesort；\n避免： where哪些字段，就order by那些字段2")])]),e._v(" "),a("li",[a("p",[e._v("复合索引：不能跨列（最佳左前缀）")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("drop idx_a1 test02;\ndrop idx_a2 idx_a3 test02;\n")])])]),a("p",[e._v("alter idx_a1_a2_a3 (a1,a2,a3) *from a3 filesort\nexplain filesort")]),e._v(" "),a("div",{staticclass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\n")])])])])]),e._v(" "),a("p",[a("strong",[e._v("理解：")]),e._v("（a1,a2,a3） [a1,a2]不夸列 跨列：[a1,a3] || [a2,a3] 都属于跨列")]),e._v(" "),a("p",[a("strong",[e._v("小结")]),e._v("：避免： where和order 按照复合索引的顺序使用，不要跨列或无序使用。（我的理解：查什么就用什么排序）")])]),e._v(" "),a("li",[a("p",[e._v("using temporary:性能损耗大 ，用到了临时表。一般出现在group 语句中")]),e._v(" in ('1','2','3') group temporary\n避免：查询那些列，就根据那些列 .（我的理解：查什么就用什么分组）\n")])])])]),e._v(" :性能提升; 索引覆盖（覆盖索引）。原因：不读取原文件，只从索引文件中获取数据 （不需要回表查询）只要使用到的列 全部都在索引中，就是索引覆盖using index")]),e._v(" "),a("p",[e._v("举例：test02表中有一个复合索引(a1,a2,a3)")]),e._v(" a1,a2 or \t\t\ndrop test02;\n\nalter idx_a1_a2(a1,a2) a1,a3 ;\n")])])]),a("ul",[a("li",[a("p",[e._v("如果用到了索引覆盖(using index时)，会对 possible_keys和key造成影响：")]),e._v(" "),a("p",[e._v("a.如果没有where，则索引只出现在key中；")]),e._v(" "),a("p",[e._v("b.如果有where，则索引 出现在key和possible_keys中。")]),e._v(" （需要回表查询）")]),e._v(" "),a("p",[e._v("假设age是索引列\n但查询语句select age,name ...where age="...,此语句中必须回原表查Name，因此会显示using" where.")]),e._v(" --a3需要回原表查询\n\t\n我的理解：先去索引中查，如果需要查索引中没有的字段则必须回表查询，即所谓的回表查询。\n")])])])]),e._v(" "),a("li",[a("p",[e._v("impossible where子句永远为false")])])]),e._v(" "),a("h3",{attrs:{id:"_6-优化案例"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_6-优化案例","aria-hidden":"true"}},[e._v("#")]),e._v(" . 优化案例")]),e._v(" "),a("ul",[a("li",[e._v("单表优化")]),e._v(" "),a("li",[e._v("两表优化")]),e._v(" "),a("li",[e._v("三表优化")])]),e._v(" "),a("h4",{attrs:{id:"_1-单表优化"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_1-单表优化","aria-hidden":"true"}},[e._v("#")]),e._v(" (1) 单表优化")]),e._v(" book\n(\n\tbid int(4) primary key,\n\tname null,\n\tauthorid null,\n\tpublicid null,\n\ttypeid \n);\ninsert into book values(1,'tjava',1,1,2) ;\ninsert values(2,'tc',2,1,2) values(3,'wx',3,2,1) values(4,'math',4,2,3) ;\t\ncommit;\t\n")])])]),a("p",[e._v("场景1：查询authorid="1且" typeid为2或3的\tbid")]),e._v(" "),a("p",[e._v("sql语句：")]),e._v(" bid typeid in(2,3) authorid="1" desc ;")])]),e._v(" "),a("blockquote",[a("p",[e._v("优化一：加索引")]),e._v(" "),a("p",[a("code",[e._v("alter idx_bta (bid,typeid,authorid);")])])]),e._v(" "),a("p",[e._v("优化过程：")]),e._v(" "),a("div",{staticclass:"language-mysq extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("索引一旦进行 升级优化，需要将之前废弃的索引删掉，防止干扰。\n之前索引：（a,b,c) 当前索引：（a,b)会有干扰，索引删除（a,b,c)索引。\n\tdrop book;\n\n根据sql实际解析的顺序，调整索引的顺序：\n(虽然可以回表查询bid，但是将bid放到索引中 可以提升使用using ;)\nalter idx_tab (typeid,authorid,bid);\n")])])]),a("blockquote",[a("p",[e._v("再次优化 （之前是index级别）：思路。因为范围查询in有时会实现，因此交换 索引的顺序，将typeid 放到最后。")])]),e._v(" book;\n\talter idx_atb (authorid,typeid,bid);\n\texplain ;\n")])])]),a("p",[e._v("优化结果：达到——ref级别")]),e._v(" "),a("p",[a("strong",[e._v("-- 小结")])]),e._v(" "),a("ul",[a("li",[e._v("1.最佳做前缀，保持索引的定义和使用的顺序一致性")]),e._v(" "),a("li",[e._v("2.索引需要逐步优化")]),e._v(" "),a("li",[e._v("3.将含in的范围查询 放到where条件的最后，防止失效")])]),e._v(" "),a("p",[e._v("注意：")]),e._v(" "),a("div",{staticclass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("本例中同时出现了using where（需要回原表）;\n using index（不需要回原表）：\n原因，where in(2,3)中authorid在索引(authorid,typeid,bid)中，因此不需要回原表（直接在索引表中能查到）；\n \ntypeid虽然也在索引(authorid,typeid,bid)中，但是含in的范围查询已经使该typeid索引失效，因此相当于没有 typeid这个索引，所以需要回原表（using where）；\n \n例如以下没有了in，则不会出现using where\n\texplain ;\n\n还可以通过key_len证明in可以使索引失效。\n")])])]),a("h4",{attrs:{id:"_2-两表优化"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_2-两表优化","aria-hidden":"true"}},[e._v("#")]),e._v(" (2) 两表优化")]),e._v(" "),a("blockquote",[a("p",[e._v("创建表的sql语句")])]),e._v(" teacher2\n(\n\ttid key,\n\tcid null\n);\n\ninsert teacher2 values(1,2);\ninsert values(2,1);\ninsert values(3,3);\n\ncreate course2\n(\n\tcid ,\n\tcname varchar(20)\n);\n\ninsert course2 values(1,'java');\ninsert values(2,'python');\ninsert values(3,'kotlin');\ncommit;\n")])])]),a("ul",[a("li",[e._v("左连接")])]),e._v(" left outer join t.cid="c.cid" "),a("p",[e._v("优化知识补充：")]),e._v(" "),a("p",[a("strong",[e._v("(1) 索引往哪张表加？")])]),e._v(" "),a("blockquote",[a("p",[e._v("小表驱动大表")])]),e._v(" "),a("p",[e._v("​ 索引建立经常使用的字段上 （本题 [一般情况对于左外连接，给左表加索引；右外连接，给右表加索引]")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("小表：10\n大表：300\n 小表.x 300; --循环了几次？10\n\n 大表.y 10\t--循环了300次\n \n小表:10\n大表:300\n\n\tselect 小表.x10="大表.x300" ;\n\tfor(int i="0;i<小表.length10;i++)\n\t{\n\t\tfor(int" j="0;j<大表.length300;j++)\n\t\t{\n\t\t\t...\n\t\t}\n\t}" \n 对比：\n 大表.x300="小表.x10" 对于双层循环来说：一般建议 将数据小的循环 放外层；数据大的循环放内存")])]),e._v(" "),a("p",[a("strong",[e._v("(2) 优化过程")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("当编写 ..on 时，将数据量小的表 放左边（假设此时t表数据量小）")]),e._v(" index_teacher2_cid(cid) ;\nalter index_course2_cname(cname);\n")])])]),a("p",[a("strong",[e._v("using buffer:extra中的一个选项，作用：mysql引擎使用了 连接缓存。")])])])]),e._v(" "),a("p",[e._v("优化后的ref级别：")]),e._v(" "),a("h4",{attrs:{id:"_3-三表优化"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_3-三表优化","aria-hidden":"true"}},[e._v("#")]),e._v(" (3) 三表优化")]),e._v(" "),a("ul",[a("li",[e._v("三张表优化a b c")]),e._v(" "),a("li",[e._v("1,小表驱动大表")]),e._v(" "),a("li",[e._v("2,索引建立在经常查询的字段上")])]),e._v(" "),a("p",[e._v("创建表：")]),e._v(" "),a("pre",[a("code",[e._v("​```mysql\n")])]),e._v(" "),a("p",[e._v("create test03\n(\na1 null,\na2 null,\na3 null,\na4 null\n);")]),e._v(" "),a("p",[e._v("alter test03 idx_a1_a2_a3_4(a1,a2,a3,a4) ;")]),e._v(" "),a("p",[e._v("explain a1,a2,a3,a4 a4="4" ;\n--推荐写法，因为 索引的使用顺序（where后面的顺序） 和 复合索引的顺序一致")]),e._v(" ;\n--虽然编写的顺序 和索引顺序不一致，但是 sql在真正执行前 经过了sql优化器的调整，结果与上条sql是一致的。\n--以上 2个sql，使用了 全部的复合索引")]),e._v(" a3;\n--以上sql用到了a1 a2两个索引，该两个字段 不需要回表查询using ;而a4因为跨列使用，造成了该索引失效，需要回表查询 因此是using where；以上可以通过 key_len进行验证")]),e._v(" "),a("pre",[a("code",[e._v("我的理解：如果跨列则会产生回表查询产生无效索引\n")])]),e._v(" a3;\n--以上sql出现了 filesort(文件内排序，“多了一次额外的查找 排序”) ：不要跨列使用( 拼起来，不要跨列使用)")]),e._v(" , a3; --不会using filesort\n```")]),e._v(" "),a("p",[a("strong",[e._v("总结")])]),e._v(" "),a("blockquote",[a("ul",[a("li",[e._v("如果 (a,b,c,d)复合索引 和使用的顺序全部一致(且不跨列使用)，则复合索引全部使用。如果部分一致(且不跨列使用)，则使用部分索引。select a,c a="and" d=")]),e._v(" "),a("li",[e._v("iwhere和order 拼起来，不要跨列使用")])]),e._v(" "),a("p",[a("strong",[e._v("using temporary:需要额外再多使用一张表. 一般出现在group by语句中；已经有表了，但不适用，必须再来一张表。")])])]),e._v(" "),a("p",[a("strong",[e._v("解析过程")])]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("from .. on.. ..where ..group ....having ...select dinstinct ..order limit ...\na.\nexplain a2,a4 ;--没有using temporary\nb.\nexplain ;\n")])])]),a("h3",{attrs:{id:"_7-避免索引失效的一些原则"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_7-避免索引失效的一些原则","aria-hidden":"true"}},[e._v("#")]),e._v(" 7.避免索引失效的一些原则")]),e._v(" "),a("blockquote",[a("p",[e._v("(1) 复合索引")]),e._v(" "),a("ul",[a("li",[e._v("复合索引，不要跨列或无序使用（最佳左前缀）（a,b,c）")]),e._v(" "),a("li",[e._v("复合索引，尽量使用全索引匹配 (a,b,c) [用到的字段都用索引]")])]),e._v(" "),a("p",[e._v("(2) 不要在索引上进行任何操作（计算、函数、类型转换），否则索引失效（单独索引不影响）")]),e._v(" "),a("p",[e._v("举例：book表")])]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select a.x=".." --假设a.x是索引\n不要：select a.x*3=".." ;\n假设（a,t,b）是一个复合索引\nexplain ;--用到了at 2个索引\nexplain typeid*2="2" ;--用到了a 1个索引\nexplain authorid*2="1" ;----用到了 0个索引\nexplain ;----用到了0个索引,\n原因：对于复合索引，如果左边失效，右侧全部失效。(a,b,c)，例如如果 b失效，则b c同时失效。\n\ndrop idx_authroid (authorid) idx_typeid (typeid) ;\n")])])]),a("blockquote",[a("p",[e._v("(3) 复合索引不能使用不等于（!="<">）或is null (is not null)，否则自身以及右侧所有全部失效。复合索引中如果有>，则自身和右侧索引全部失效。")])]),e._v(" "),a("p",[a("code",[e._v("explain select * from book where authorid = 1 and typeid =2 ;")])]),e._v(" "),a("p",[e._v("注意：")]),e._v(" "),a("ul",[a("li",[e._v("SQL优化，是一种概率层面的优化。至于是否实际使用了我们的优化，需要通过explain进行推测。")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select * from book where authorid != 1 and typeid =2 ;\nexplain select * from book where authorid != 1 and typeid !=2 ;\n")])])]),a("p",[a("strong",[e._v("体验概率情况(< > =)：原因是服务层中有SQL优化器，可能会影响我们的优化。")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("drop index idx_typeid on book;\ndrop index idx_authroid on book;\nalter table book add index idx_book_at (authorid,typeid);\nexplain select * from book where authorid = 1 and typeid =2 ;--复合索引at全部使用\nexplain select * from book where authorid > 1 and typeid =2 ; --复合索引中如果有>，则自身和右侧索引全部失效。\nexplain select * from book where authorid = 1 and typeid >2 ;--复合索引at全部使用\n----明显的概率问题---\nexplain select * from book where authorid < 1 and typeid =2 ;--复合索引at只用到了1个索引\nexplain select * from book where authorid < 4 and typeid =2 ;--复合索引全部失效\n")])])]),a("blockquote",[a("p",[e._v("我们学习索引优化 ，是一个大部分情况适用的结论，但由于SQL优化器等原因  该结论不是100%正确。\n一般而言， 范围查询（> <  in），之后的索引失效。")])]),e._v(" "),a("blockquote",[a("p",[e._v("(4) 补救。尽量使用索引覆盖（using index）.比如（a,b,c）")]),e._v(" "),a("p",[a("code",[e._v("select a,b,c from xx..where a= .. and b =.. ;")])])]),e._v(" "),a("blockquote",[a("p",[e._v("(5) like尽量以“常量”开头，不要以'%'开头，否则索引失效")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select * from xx where name like '%x%' ; --name索引失效\t\nexplain select * from teacher  where tname like '%x%'; --tname索引失效\nexplain select * from teacher  where tname like 'x%';\nexplain select tname from teacher  where tname like '%x%';\n--如果必须使用like '%x%'进行模糊查询，可以使用索引覆盖 挽救一部分。\n")])])]),a("blockquote",[a("p",[e._v("（6）尽量不要使用类型转换（显示、隐式），否则索引失效")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select * from teacher where tname = 'abc' ;\nexplain select * from teacher where tname = 123 ;//程序底层将 123 -> '123'，即进行了类型转换，因此索引失效\n")])])]),a("blockquote",[a("p",[e._v("（7）尽量不要使用or，否则索引失效")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("explain select * from teacher where tname ='' or tcid >1 ; --将or左侧的tname 失效。\n")])])]),a("h3",{attrs:{id:"_8-其他的优化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-其他的优化方法","aria-hidden":"true"}},[e._v("#")]),e._v(" 8. 其他的优化方法")]),e._v(" "),a("h4",{attrs:{id:"（1）exist和in"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）exist和in","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）exist和in")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select ..from table where exist (子查询) ;\nselect ..from table where 字段 in  (子查询) ;\n")])])]),a("ul",[a("li",[e._v("如果主查询的数据集大，则使用In   , 效率高。\n如果子查询的数据集大，则使用exist, 效率高。")]),e._v(" "),a("li",[e._v("我的理解：想要效率高：子查询"),a("strong",[e._v("数据集大就用exist")]),e._v(",子查询"),a("strong",[e._v("数据集小就用in")]),e._v("进行对应的子查询")])]),e._v(" "),a("p",[e._v("语法复习：")]),e._v(" "),a("blockquote",[a("p",[e._v("exist语法： 将主查询的结果，放到子查需结果中进行条件校验（看子查询是否有数据，如果有数据 则校验成功）, 如果 复合校验，则保留数据；")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select tname from teacher where exists (select * from teacher) ; \n   --等价于select tname from teacher\nselect tname from teacher where exists (select * from teacher where tid =9999) ;\n\nin:\nselect ..from table where tid in  (1,3,5) ;\n")])])])]),e._v(" "),a("h4",{attrs:{id:"（2）order-by-优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）order-by-优化","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）order by 优化")]),e._v(" "),a("p",[e._v("​    "),a("strong",[e._v("using filesort 有两种算法：双路排序、单路排序 （根据IO的次数）")])]),e._v(" "),a("blockquote",[a("p",[e._v("MySQL4.1之前 默认使用 双路排序；双路：扫描2次磁盘")]),e._v(" "),a("ul",[a("li",[e._v("1,从磁盘读取排序字段 ,对排序字段进行排序（在buffer中进行的排序）")]),e._v(" "),a("li",[e._v("2，扫描其他字段 ）")])]),e._v(" "),a("p",[e._v("注意："),a("strong",[e._v("IO较消耗性能")])])]),e._v(" "),a("blockquote",[a("p",[e._v("MySQL4.1之后 默认使用 单路排序  ： 只读取一次（全部字段），在buffer中进行排序。")]),e._v(" "),a("ul",[a("li",[e._v("但种单路排序 会有一定的隐患 （不一定真的是“单路|1次IO”，有可能多次IO）。")]),e._v(" "),a("li",[e._v("原因：如果数据量特别大，则无法 将所有字段的数据 一次性读取完毕，因此 会进行“分片读取、多次读取”。")])])]),e._v(" "),a("p",[e._v("注意：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("1，单路排序 比双路排序 会占用更多的buffer。")])]),e._v(" "),a("li",[a("p",[e._v("2，单路排序在使用时，如果数据大，可以考虑调大buffer的容量大小：")]),e._v(" "),a("p",[a("code",[e._v("set max_length_for_sort_data = 1024 单位byte")])])]),e._v(" "),a("li",[a("p",[e._v("3，如果max_length_for_sort_data值太低，则mysql会自动从 单路->双路")]),e._v(" "),a("p",[e._v("解释：(太低：需要排序的列的总大小超过了max_length_for_sort_data定义的字节数）")])])]),e._v(" "),a("p",[a("strong",[e._v("提高order by查询的策略：")])]),e._v(" "),a("blockquote",[a("p",[e._v("a.选择使用单路、双路 ；调整buffer的容量大小；\nb.避免select * ..."),a("br"),e._v("\nc.复合索引 不要跨列使用 ，避免using filesort\nd.保证全部的排序字段 排序的一致性（都是升序 或 降序）")])]),e._v(" "),a("h3",{attrs:{id:"_9-sql排查-慢查询日志"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-sql排查-慢查询日志","aria-hidden":"true"}},[e._v("#")]),e._v(" 9. SQL排查 - 慢查询日志")]),e._v(" "),a("p",[a("strong",[e._v("MySQL提供的一种日志记录，用于记录MySQL种响应时间超过阀值的SQL语句 （long_query_time，默认10秒）")])]),e._v(" "),a("ul",[a("li",[e._v("查询日志默认是关闭的；")]),e._v(" "),a("li",[e._v("建议：开发调优是 打开，而 最终部署时关闭。")])]),e._v(" "),a("h4",{attrs:{id:"（1）基本操作-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）基本操作-2","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）基本操作")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("检查是否开启了 慢查询日志 ：   show variables like '%slow_query_log%' ;")])]),e._v(" "),a("li",[a("p",[e._v("临时开启：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("set global slow_query_log = 1 ;  --在内存种开启\nexit\nservice mysql restart\n")])])])]),e._v(" "),a("li",[a("p",[e._v("永久开启：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/etc/my.cnf 中追加配置：\nvi /etc/my.cnf \n[mysqld]\nslow_query_log=1\nslow_query_log_file=/var/lib/mysql/localhost-slow.log\n")])])])]),e._v(" "),a("li",[a("p",[e._v("慢查询阀值：")]),e._v(" "),a("p",[a("code",[e._v("show variables like '%long_query_time%' ;")])])]),e._v(" "),a("li",[a("p",[e._v("临时设置阀值：")])])]),e._v(" "),a("p",[e._v("​     "),a("code",[e._v("set global long_query_time = 5 ; --设置完毕后，重新登陆后起效 （不需要重启服务）")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("永久设置阀值：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("/etc/my.cnf 中追加配置：\nvi /etc/my.cnf \n[mysqld]\nlong_query_time=3\n")])])])])]),e._v(" "),a("blockquote",[a("p",[e._v("select sleep(4);\nselect sleep(5);\nselect sleep(3);\nselect sleep(3);")]),e._v(" "),a("ul",[a("li",[e._v("查询超过阀值的SQL：  show global status like '%slow_queries%' ;")])])]),e._v(" "),a("h4",{attrs:{id:"（2）慢查询的定位方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）慢查询的定位方式","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）慢查询的定位方式")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("(1)慢查询的sql被记录在了日志中，因此可以通过日志 查看具体的慢SQL。\n"),a("code",[e._v("cat /var/lib/mysql/localhost-slow.log")])])]),e._v(" "),a("li",[a("p",[e._v("(2)通过mysqldumpslow工具查看慢SQL,可以通过一些过滤条件 快速查找出需要定位的慢SQL")]),e._v(" "),a("blockquote",[a("p",[e._v("mysqldumpslow --help")]),e._v(" "),a("p",[e._v("s：排序方式\nr:逆序\nl:锁定时间\ng:正则匹配模式")])])])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('--获取返回记录最多的3个SQL\n\tmysqldumpslow -s r -t 3  /var/lib/mysql/localhost-slow.log\n\n--获取访问次数最多的3个SQL\n\tmysqldumpslow -s c -t 3 /var/lib/mysql/localhost-slow.log\n\n--按照时间排序，前10条包含left join查询语句的SQL\n\tmysqldumpslow -s t -t 10 -g "left join" /var/lib/mysql/localhost-slow.log\n\t\n语法：\n\tmysqldumpslow 各种参数  慢查询日志的文件\n')])])]),a("h3",{attrs:{id:"_10-分析海量数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-分析海量数据","aria-hidden":"true"}},[e._v("#")]),e._v(" 10.分析海量数据")]),e._v(" "),a("h4",{attrs:{id:"_1-模拟海量数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-模拟海量数据","aria-hidden":"true"}},[e._v("#")]),e._v(" (1).模拟海量数据")]),e._v(" "),a("ul",[a("li",[e._v("模拟海量数据  存储过程（无return）/存储函数（有return）")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create table dept\n(\ndno int(5) primary key default 0,\ndname varchar(20) not null default '',\nloc varchar(30) default ''\n)engine=innodb default charset=utf8;\n\ncreate table emp\n(\neid int(5) primary key,\nename varchar(20) not null default '',\njob varchar(20) not null default '',\ndeptno int(5) not null default 0\n)engine=innodb default charset=utf8;\n")])])]),a("ul",[a("li",[a("p",[e._v("通过存储函数 插入海量数据：")])]),e._v(" "),a("li",[a("p",[e._v("创建存储函数：(创建随机字符串，用来模拟字段)")]),e._v(" "),a("p",[a("code",[e._v("randstring(6) ->aXiayx 用于模拟员工名称")])])]),e._v(" "),a("li",[a("p",[e._v("0-1 *52 [0 52)")])]),e._v(" "),a("li",[a("p",[e._v("delimiter[定界符] $")])])]),e._v(" "),a("p",[e._v("创建存储过程函数的sql语法：")]),e._v(" "),a("ul",[a("li",[e._v("（1）产生随机字符串")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("delimiter $ \n\tcreate function randstring(n int)   returns varchar(255) \n\tbegin\n\t\tdeclare  all_str varchar(100) default                          'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' ;\n\t\tdeclare return_str varchar(255) default '' ;\n\t\tdeclare i int default 0 ; \n\t\twhile i<n\t\t 780 \n\t\tdo\t\t\t\t\t\t\t\t\t \n\t\t\tset return_str="concat(return_str," substring(all_str, floor(1+rand()*52),1));\n\t\t\tset i="i+1" ;\n\t\tend while ;\n\t\treturn return_str;\t\n\tend $ \n")])])]),a("p",[a("strong",[e._v("注意：")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("若提示：display all possibilities? (y or n)，则 删除语句中所有疑似tab键，再次执行，问题解决！")])]),e._v(" "),a("li",[a("p",[e._v("如果报错：you have an error in your sql syntax，说明sql语句语法有错，需要修改sql语句；")])]),e._v(" "),a("li",[a("p",[e._v("如果报错this function has none of deterministic, no sql, reads data its declaration and binary logging is enabled (you "),a("em",[e._v("might")]),e._v(" want to use the less safe log_bin_trust_function_creators variable)")])])]),e._v(" "),a("p",[e._v("是因为 存储过程 存储函数在创建时 与之前的 开启慢查询日志冲突了")]),e._v(" "),a("p",[a("strong",[e._v("解决冲突：")])]),e._v(" "),a("blockquote",[a("p",[e._v("1,临时解决( 开启log_bin_trust_function_creators )")]),e._v(" "),a("p",[e._v("show variables like '%log_bin_trust_function_creators%';\nset global "),a("p",[e._v("2,永久解决：")]),e._v(" "),a("p",[e._v(" etc my.cnf\n[mysqld]下设置如下字段：\nlog_bin_trust_function_creators="1" )])]),e._v("" "),a("p",[e._v("（2）产生随机整数")]),e._v(" "),a("div",{staticclass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create ran_num() returns int(5)\nbegin\n\tdeclare int default 0;\n\tset rand()*100 ) ;\n\treturn ;\n\nend $\n")])])]),a("p",[e._v("(3) 通过存储过程插入海量数据：emp表中 ， 10000, 100000")]),e._v(" procedure insert_emp( eid_start int(10),in data_times int(10))\nbegin \n\tdeclare autocommit="0" ;\n\t\n\trepeat\n\t\t\n\t\tinsert into emp values(eid_start + i, randstring(5) ,'other' ,ran_num()) ;\n\t\tset ;\n\t\tuntil repeat ;\n\tcommit ;\nend $\n")])])]),a("p",[e._v("(4) 通过存储过程插入海量数据：dept表中")]),e._v(" insert_dept(in dno_start int(10) ,in int(10))\nbegin\n\tdeclare ;\n\trepeat\n\t\n\t\tinsert dept values(dno_start+i ,randstring(6),randstring(8)) ;\ncommit ;\nend$\n")])])]),a("p",[e._v("(5) 插入数据")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v(" 定义分割符 改为 ；\ndelimiter ; \ncall insert_emp(1000,800000) ;\ncall insert_dept(10,30) ;\n\n")])])]),a("h4",{attrs:{id:"_2-分析海量数据"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_2-分析海量数据","aria-hidden":"true"}},[e._v("#")]),e._v(" (2).分析海量数据")]),e._v(" "),a("blockquote",[a("h5",{attrs:{id:"_1-profiles"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_1-profiles","aria-hidden":"true"}},[e._v("#")]),e._v(" 1,profiles")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("show profiles --默认关闭")])]),e._v(" "),a("li",[a("p",[e._v("show '%profiling%';")])]),e._v(" "),a("li",[a("p",[e._v("set profiling="on" ;")]),e._v(" "),a("p",[e._v("解释说明：show ：会记录所有profiling打开之后的 全部sql查询语句所花费的时间。缺点：不够精确，只能看到 总共消费的时间，不能看到各个硬件消费的时间（cpu io ）")])])])]),e._v(" "),a("blockquote",[a("h5",{attrs:{id:"_2-精确分析-sql诊断"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_2-精确分析-sql诊断","aria-hidden":"true"}},[e._v("#")]),e._v(" 2,精确分析:sql诊断")]),e._v(" "),a("ul",[a("li",[e._v("show profile for query 上一步查询的的query_id")]),e._v(" "),a("li",[e._v("show cpu,block 上一步查询的的query_id")])]),e._v(" "),a("h5",{attrs:{id:"_3-全局查询日志"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_3-全局查询日志","aria-hidden":"true"}},[e._v("#")]),e._v(" 3,全局查询日志")]),e._v(" "),a("p",[e._v("​ 记录开启之后的 全部sql语句。 （这次全局的记录操作 仅仅在调优、开发过程中打开即可，在最终的部署实施时 一定关闭）;")]),e._v(" "),a("p",[e._v("操作指令：show '%general_log%';")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("执行的所有sql记录在表中")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("show '%general_log%'; --查看全局日志是否开启\nset general_log="1" ;--开启全局日志\nset log_output="table" --设置 将全部的sql 记录在表中\n")])])])]),e._v(" "),a("li",[a("p",[e._v("执行的所有sql记录在文件中")]),e._v(" extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("set ;\nset general_log_file="/tmp/general.log" ;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("开启后，会记录所有sql ： 会被记录 mysql.general_log表中。")]),e._v(" "),a("p",[a("code",[e._v("select * from mysql.general_log ;")])])])])]),e._v(" "),a("h3",{attrs:{id:"_11-锁机制"}},[a("a",{staticclass:"header-anchor",attrs:{href:"#_11-锁机制","aria-hidden":"true"}},[e._v("#")]),e._v(" 11. 锁机制")]),e._v(" "),a("p",[e._v("定义：解决因资源共享 而造成的并发问题。")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("示例：买最后一件衣服x")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("a: \tx\t买 x加锁 ->试衣服...下单..付款..打包 ->X解锁")])]),e._v(" "),a("tr",[a("td",[e._v("B:\tX       买：发现X已被加锁，等待X解锁，   X已售空")])])])]),e._v(" "),a("h4",{attrs:{id:"（1）分类-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（1）分类-2","aria-hidden":"true"}},[e._v("#")]),e._v(" （1）分类")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("操作类型")]),e._v(" "),a("p",[e._v("a.读锁（共享锁）： 对同一个数据（衣服），多个读操作可以同时进行，互不干扰。\nb.写锁（互斥锁）： 如果当前写操作没有完毕（买衣服的一系列操作），则无法进行其他的读操作、写操作")])]),e._v(" "),a("li",[a("p",[e._v("操作范围")]),e._v(" "),a("p",[e._v("a.表锁：")]),e._v(" "),a("p",[e._v("​         一次性对"),a("strong",[e._v("一张表整体")]),e._v("加锁。如MyISAM存储引擎使用表锁，开销小、加锁快；无死锁；但锁的范围大，容易发生锁冲突、并发度低。")]),e._v(" "),a("p",[e._v("b.行锁 ：")]),e._v(" "),a("p",[e._v("​         一次性对"),a("strong",[e._v("一条数据")]),e._v("加锁。如InnoDB存储引擎使用行锁，开销大，加锁慢；容易出现死锁；锁的范围较小，不易发生锁冲突，并发度高（很小概率 发生高并发问题：脏读、幻读、不可重复度、丢失更新等问题）。\nc.页锁")])])]),e._v(" "),a("h4",{attrs:{id:"（2）实例实战"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#（2）实例实战","aria-hidden":"true"}},[e._v("#")]),e._v(" （2）实例实战")]),e._v(" "),a("h5",{attrs:{id:"_1-表锁（myisam）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-表锁（myisam）","aria-hidden":"true"}},[e._v("#")]),e._v(" 1.\t表锁（MyISAM）")]),e._v(" "),a("blockquote",[a("p",[e._v("自增操作 MYSQL/SQLSERVER 支持；oracle需要借助于序列来实现自增")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("举例")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create table tablelock\n(\nid int primary key auto_increment , \nname varchar(20)\n   )engine myisam;\n\ninsert into tablelock(name) values('a1');\ninsert into tablelock(name) values('a2');\ninsert into tablelock(name) values('a3');\ninsert into tablelock(name) values('a4');\ninsert into tablelock(name) values('a5');\ncommit;\n")])])]),a("p",[a("strong",[e._v("（1）增加锁语法：")])]),e._v(" "),a("p",[e._v("​     "),a("code",[e._v("lock table 表1 read/write ,表2 read/write ,...")])]),e._v(" "),a("p",[e._v("（2）查看加锁的表：")]),e._v(" "),a("p",[e._v("​     "),a("code",[e._v("show open tables ;")])]),e._v(" "),a("ul",[a("li",[e._v("**注意：**会话(session) :每一个访问数据的dos命令行、数据库客户端工具  都是一个会话")])]),e._v(" "),a("p",[e._v("（3）加读锁：")]),e._v(" "),a("p",[e._v("​      "),a("code",[e._v("lock table tablelock read;")])]),e._v(" "),a("p",[e._v("​    "),a("strong",[e._v("会话0")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("lock table  tablelock read ;\nselect * from tablelock; --读（查），可以\ndelete from tablelock where id =1 ; --写（增删改），不可以\n\nselect * from emp ; --读，不可以\ndelete from emp where eid = 1; --写，不可以\n结论1：\n  --如果某一个会话 对A表加了read锁，则 该会话 可以对A表进行读操作、不能进行写操作； 且 该会话不能对其他表进行读、写操作。\n  --即如果给A表加了读锁，则当前会话只能对A表进行读操作。\n")])])]),a("ul",[a("li",[a("p",[e._v("其他会话对会话0加锁后的操作情况 ：")]),e._v(" "),a("p",[a("strong",[e._v("会话1")]),e._v("（其他会话）")])])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select * from tablelock;   --读（查），可以\ndelete from tablelock where id =1 ; --写，会“等待”会话0将锁释放\n")])])]),a("ul",[a("li",[e._v("其他会话对其他未加锁表的操作情况：")])]),e._v(" "),a("p",[a("strong",[e._v("会话2")]),e._v("（其他会话）")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("select * from emp ;  --读（查），可以\ndelete from emp where eid = 1; --写，可以\n结论2：\n--总结：\n\t会话0给A表加了锁；其他会话的操作：\n\t          a.可以对其他表（A表以外的表）进行读、写操作。\n               b.对A表：读-可以；写-需要等待释放锁。\n")])])]),a("p",[e._v("(4) 释放锁")]),e._v(" "),a("p",[e._v("​    "),a("code",[e._v("unlock tables ;")])]),e._v(" "),a("p",[e._v("​")]),e._v(" "),a("p",[a("strong",[e._v("（5）加写锁的操作")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("会话0")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("lock table tablelock write ;\n\n当前会话（会话0） 可以对加了写锁的表  进行任何操作（增删改查）；但是不能 操作（增删改查）其他表\n")])])])]),e._v(" "),a("li",[a("p",[e._v("会话1（其他会话）")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("对会话0中加写锁的表 可以进行增删改查的前提是：等待会话0释放写锁\n")])])])])]),e._v(" "),a("p",[e._v("​    "),a("strong",[e._v("（6）MySQL表级锁的锁模式")])]),e._v(" "),a("p",[e._v("​            MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（DML）前，会自动给涉及的表加写锁。所以对MyISAM表进行操作，会有以下情况：\na、对MyISAM表的读操作（加读锁），不会阻塞其他进程（会话）对同一表的读请求，\n但会阻塞对同一表的写请求。只有当读锁释放后，才会执行其它进程的写操作。\nb、对MyISAM表的写操作（加写锁），会阻塞其他进程（会话）对同一表的读和写操作，\n只有当写锁释放后，才会执行其它进程的读写操作。")]),e._v(" "),a("p",[e._v("​     "),a("strong",[e._v("（7）分析表锁定：")])]),e._v(" "),a("blockquote",[a("ul",[a("li",[a("p",[e._v("查看哪些表加了锁:"),a("code",[e._v("show open tables ; 1代表被加了锁")])])]),e._v(" "),a("li",[a("p",[e._v("分析表锁定的严重程度：show status like 'table%' ;")]),e._v(" "),a("p",[e._v("1,Table_locks_immediate :即可能获取到的锁数.")]),e._v(" "),a("p",[e._v("2,Table_locks_waited：需要等待的表锁数《我的理解：已经加锁的个数》(如果该值越大，说明存在越大的锁竞争)")])]),e._v(" "),a("li",[a("p",[e._v("一般建议：")]),e._v(" "),a("p",[e._v("Table_locks_immediate/Table_locks_waited > 5000， 建议采用InnoDB引擎，否则MyISAM引擎")])])])])])]),e._v(" "),a("h5",{attrs:{id:"_2-行锁-innodb"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-行锁-innodb","aria-hidden":"true"}},[e._v("#")]),e._v(" 2.   行锁(innodb)")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("create table linelock(\nid int(5) primary key auto_increment,\nname varchar(20)\n)engine=innodb ;\ninsert into linelock(name) values('1')  ;\ninsert into linelock(name) values('2')  ;\ninsert into linelock(name) values('3')  ;\ninsert into linelock(name) values('4')  ;\ninsert into linelock(name) values('5')  ;\n")])])]),a("blockquote",[a("p",[e._v("mysql默认自动commit;\toracle默认不会自动commit ;")])]),e._v(" "),a("ul",[a("li",[e._v("为了研究行锁，暂时将自动commit关闭;  set autocommit =0 ; 以后需要通过commit")])]),e._v(" "),a("p",[e._v("**会话0：**写操作")]),e._v(" "),a("p",[e._v("​      "),a("code",[e._v("insert into linelock values(\t'a6') ;")])]),e._v(" "),a("p",[a("strong",[e._v("会话1：")]),e._v(" 写操作 同样的数据")]),e._v(" "),a("p",[e._v("​         "),a("code",[e._v("update linelock set name='ax' where id = 6;")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("对行锁情况：")]),e._v(" "),a("p",[e._v("1，如果会话x对某条数据a进行 DML操作（研究时：关闭了自动commit的情况下），则其他会话必须等待会话x结束事务(commit/rollback)后  才能对数据a进行操作。")]),e._v(" "),a("p",[e._v("2，表锁 是通过unlock tables，也可以通过事务解锁 ; 行锁 是通过事务解锁。")])])]),e._v(" "),a("p",[a("strong",[e._v("行锁，操作不同数据：")])]),e._v(" "),a("p",[e._v("**会话0： **写操作")]),e._v(" "),a("p",[a("code",[e._v("insert into linelock values(8,'a8') ;")])]),e._v(" "),a("p",[e._v("**会话1：**写操作， 不同的数据")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("update linelock set name='ax' where id = 5;\n行锁，一次锁一行数据；因此 如果操作的是不同数据，则不干扰。\n")])])]),a("ul",[a("li",[a("p",[e._v("行锁的注意事项：")]),e._v(" "),a("p",[e._v("a.如果没有索引，则行锁会转为表锁")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("show index from linelock ;\nalter table linelock add index idx_linelock_name(name);\n")])])]),a("table",[a("thead",[a("tr",[a("th",[e._v("会话0： 写操作")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("update linelock set name = 'ai' where name = '3' ;")])]),e._v(" "),a("tr",[a("td",[e._v("会话1： 写操作， 不同的数据")])]),e._v(" "),a("tr",[a("td",[e._v("update linelock set name = 'aiX' where name = '4' ;")])])])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("会话0： 写操作")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("update linelock set name = 'ai' where name = 3 ;")])]),e._v(" "),a("tr",[a("td",[e._v("会话1： 写操作， 不同的数据")])]),e._v(" "),a("tr",[a("td",[e._v("update linelock set name = 'aiX' where name = 4 ;")])])])])]),e._v(" "),a("li",[a("p",[e._v("可以发现，数据被阻塞了（加锁）")])]),e._v(" "),a("li",[a("p",[e._v("原因：如果索引类 发生了类型转换，则索引失效。 因此 此次操作，会从行锁 转为表锁。")]),e._v(" "),a("p",[e._v("​")]),e._v(" "),a("p",[e._v("b.行锁的一种特殊情况：间隙锁：值在范围内，但却不存在")]),e._v(" "),a("p",[e._v("此时linelock表中 没有id=7的数据")]),e._v(" "),a("p",[a("code",[e._v("update linelock set name ='x' where id >1 and id<9 ;")])]),e._v(" "),a("p",[e._v("即在此where范围中，没有id="7的数据，则id=7的数据成为间隙。" )]),e._v("" "),a("p",[a("strong",[e._v("间隙")]),e._v("：mysql会自动给 间隙 加索 ->间隙锁。即 本题 会自动给id=7的数据加 间隙锁（行锁）。\n"),a("strong",[e._v("行锁")]),e._v("：如果有where，则实际加索的范围 就是where后面的范围（不是实际的值）")]),e._v(" "),a("p",[e._v("​")]),e._v(" "),a("p",[e._v("(1) 如何仅仅是查询数据，能否加锁？ 可以   for update")]),e._v(" "),a("p",[e._v("研究学习时，将自动提交关闭：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("\tset autocommit =0 ;\n\tstart transaction ;\n\tbegin ;\n\tselect * from linelock where id =2 for update ;\n    通过for update对query语句进行加锁。\n")])])]),a("p",[e._v("(2)小结：")]),e._v(" "),a("p",[e._v("行锁：")]),e._v(" "),a("ul",[a("li",[e._v("InnoDB默认采用行锁；")]),e._v(" "),a("li",[e._v("缺点： 比表锁性能损耗大。")]),e._v(" "),a("li",[e._v("优点：并发能力强，效率高。")]),e._v(" "),a("li",[e._v("因此建议，高并发用InnoDB，否则用MyISAM。")])]),e._v(" "),a("p",[a("strong",[e._v("行锁分析：")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("show status like '%innodb_row_lock%' ;\nInnodb_row_lock_current_waits :当前正在等待锁的数量  \nInnodb_row_lock_time：等待总时长。从系统启到现在 一共等待的时间\nInnodb_row_lock_time_avg  ：平均等待时长。从系统启到现在平均等待的时间\nInnodb_row_lock_time_max  ：最大等待时长。从系统启到现在最大一次等待的时间\nInnodb_row_lock_waits ：\t等待次数。从系统启到现在一共等待的次数\n")])])]),a("p",[e._v("​")])])]),e._v(" "),a("h3",{attrs:{id:"_12-主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-主从复制","aria-hidden":"true"}},[e._v("#")]),e._v(" 12. 主从复制")]),e._v(" "),a("ul",[a("li",[e._v("集群在数据库的一种实现")]),e._v(" "),a("li",[e._v("windows:mysql 主")]),e._v(" "),a("li",[e._v("linux:mysql从")])]),e._v(" "),a("h4",{attrs:{id:"_1-安装windows版mysql"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-安装windows版mysql","aria-hidden":"true"}},[e._v("#")]),e._v(" (1) 安装windows版mysql")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("如果之前计算机中安装过Mysql，要重新再安装  则需要：先卸载 再安装")]),e._v(" "),a("p",[e._v("先卸载：")]),e._v(" "),a("p",[e._v("​      1,通过电脑自带卸载工具卸载Mysql (电脑管家也可以)")]),e._v(" "),a("p",[e._v("​      2,删除一个mysql缓存文件C:\\ProgramData\\MySQL")]),e._v(" "),a("p",[e._v("​      3,删除注册表regedit中所有mysql相关配置")]),e._v(" "),a("p",[e._v("​      4,重启计算机")])]),e._v(" "),a("li",[a("p",[e._v("安装MYSQL：")]),e._v(" "),a("p",[e._v("​        安装时，如果出现未响应：  则重新打开D:\\MySQL\\MySQL Server 5.5\\bin\\MySQLInstanceConfig.exe")])]),e._v(" "),a("li",[a("p",[e._v("图形化客户端： SQLyog, Navicat")])])]),e._v(" "),a("p",[a("strong",[e._v("注意")]),e._v(" ：如果要远程连接数据库，则需要授权远程访问。")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("授权远程访问 :(A->B,则再B计算机的Mysql中执行以下命令)")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n")])])])]),e._v(" "),a("li",[a("p",[e._v("如果仍然报错：可能是防火墙没关闭 ：  在B关闭防火墙  service iptables stop")])])]),e._v(" "),a("h4",{attrs:{id:"_2-实现主从复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-实现主从复制","aria-hidden":"true"}},[e._v("#")]),e._v(" (2) 实现主从复制")]),e._v(" "),a("p",[e._v("1.master将改变的数 记录在本地的 二进制日志中（binary log） ；该过程 称之为：二进制日志件事\n2.slave将master的binary log拷贝到自己的 relay log（中继日志文件）中\n3.中继日志事件，将数据读取到自己的数据库之中")]),e._v(" "),a("ul",[a("li",[e._v("MYSQL主从复制 是异步的，串行化的， 有延迟")])]),e._v(" "),a("p",[a("strong",[e._v("master:slave = 1:n")])]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("配置：windows(mysql: my.ini)")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("strong",[e._v("linux(mysql: my.cnf)")])])])])]),e._v(" "),a("p",[a("strong",[e._v("1，配置前")]),e._v("：为了无误，先将权限(远程访问)、防火墙等处理：")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("关闭windows/linux防火墙： windows：右键“网络”   ,linux: service iptables stop")])]),e._v(" "),a("li",[a("p",[e._v("Mysql允许远程连接(windowos/linux)：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'root' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\n")])])])])]),e._v(" "),a("p",[a("strong",[e._v("2,主机")]),e._v("（以下代码和操作 全部在主机windows中操作）：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("my.ini\n[mysqld]\n#id\nserver-id=1\n#二进制日志文件（注意是/  不是\\）\nlog-bin=\"D:/MySQL/MySQL Server 5.5/data/mysql-bin\"\n#错误记录文件\nlog-error=\"D:/MySQL/MySQL Server 5.5/data/mysql-error\"\n#主从同步时 忽略的数据库\nbinlog-ignore-db=mysql\n#(可选)指定主从同步时，同步哪些数据库\nbinlog-do-db=test\t\nwindows中的数据库 授权哪台计算机中的数据库 是自己的从数据库：\t\n GRANT REPLICATION slave,reload,super ON *.* TO 'root'@'192.168.2.%' IDENTIFIED BY 'root';\n flush privileges ; \n\n查看主数据库的状态（每次在左主从同步前，需要观察 主机状态的最新值）\nshow master status;  （mysql-bin.000001、 107）\n")])])]),a("p",[a("strong",[e._v("2,从机")]),e._v("（以下代码和操作 全部在从机linux中操作）：")]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("my.cnf\n[mysqld]\nserver-id=2\nlog-bin=mysql-bin\nreplicate-do-db=test\n\nlinux中的数据 授权哪台计算机中的数控 是自己的主计算机\nCHANGE MASTER TO \nMASTER_HOST = '192.168.2.2', \nMASTER_USER = 'root', \nMASTER_PASSWORD = 'root', \nMASTER_PORT = 3306,\nmaster_log_file='mysql-bin.000001',\nmaster_log_pos=107;\n\t如果报错：This operation cannot be performed with a running slave; run STOP SLAVE first\n\t解决：STOP SLAVE ;再次执行上条授权语句\n")])])]),a("p",[a("strong",[e._v("3,开启主从同步：")])]),e._v(" "),a("div",{staticClass:"language-mysql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("从机linux:\nstart slave ;\n检验  show slave status \\G\t\n主要观察： Slave_IO_Running和 Slave_SQL_Running，确保二者都是yes；如果不都是yes，则看下方的 Last_IO_Error。\n本次 通过 Last_IO_Error发现错误的原因是 主从使用了相同的server-id， \n检查:在主从中分别查看serverid:  show variables like 'server_id' ;\n可以发现，在Linux中的my.cnf中设置了server-id=2，但实际执行时 确实server-id=1，原因：可能是 linux版Mysql的一个bug，也可能是 windows和Linux版本不一致造成的兼容性问题。\n解决改bug： set global server_id =2 ;\n\tstop slave ;\n\tset global server_id =2 ;\n\tstart slave ;\n\tshow slave status \\G\n\t\n\t演示：\n\t主windows =>从\n\n\twindows:\n\t将表，插入数据  \n\t观察从数据库中该表的数据\n")])])]),a("p",[a("strong",[e._v("4,主要场景；")])]),e._v(" "),a("ul",[a("li",[a("p",[e._v("数据库+后端")]),e._v(" "),a("p",[e._v("spring boot（企业级框架,目前使用较多）")])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.bilibili.com/watchlater/#/av29072634/p9",target:"_blank",rel:"noopener noreferrer"}},[e._v("视频记录"),a("OutboundLink")],1)])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/81922471?utm_source=qq&utm_medium=social&utm_oi=829272701691658240",target:"_blank",rel:"noopener noreferrer"}},[e._v("优秀笔记地址"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);t.default=n.exports}}]);</9></n\t\t></3>